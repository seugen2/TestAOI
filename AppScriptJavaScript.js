<script>
  let randomizedQuestions = [
      {
          "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
          "options": [
              "FalseCall[003]",
              "Improper_Placement[310]",
              "Damaged _Lifted_pad[102]",
              "Insufficient_Solder[402]",
              "Excess Solder[403]"
          ],
          "correctOption": 2,
          "framesFolder": "https://drive.google.com/drive/folders/1cOZzy7krGvC_G2Ck_IjNxzI13SuJ4EE6?usp=drive_link",
          "totalFrames": 170
      },
      {
          "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
          "options": [
              "Coplanarity_ Component_Lead[316]",
              "Damaged _Lifted_pad[102]",
              "Solder_Balls_Splashes[408]",
              "Tombstoned_Component[307]",
              "FalseCall[003]"
          ],
          "correctOption": 1,
          "framesFolder": "https://drive.google.com/drive/folders/1PSLqD_ITCGqADbE_nk3MbDo33eGMFl1C?usp=drive_link",
          "totalFrames": 165
      },
      {
          "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
          "options": [
              "Missing_Component[306]",
              "FalseCall[003]",
              "Wrong_Orientation[309]",
              "Damaged _Lifted_pad[102]",
              "Damaged_Leads[303]"
          ],
          "correctOption": 3,
          "framesFolder": "https://drive.google.com/drive/folders/14fy6nEbx4H82SKoZA6zdIb_uqBtrM8C6?usp=drive_link",
          "totalFrames": 177
      },
      {
          "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
          "options": [
              "Missing_Component[306]",
              "FalseCall[003]",
              "Wrong_Component[304]",
              "Contamination[705]",
              "Solder_Bridge[409]"
          ],
          "correctOption": 3,
          "framesFolder": "https://drive.google.com/drive/folders/1sP5tvLqmkEZnZ0PHXul7MCGRo6RwCoYD?usp=drive_link",
          "totalFrames": 171
      },
      {
      "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
      "options": [
          "Coplanarity_ Component_Lead[316]",
          "Excess Solder[403]",
          "Solder_Bridge[409]",
          "Damaged_Leads[303]",
          "FalseCall[003]"
      ],
      "correctOption": 1,
      "framesFolder": "https://drive.google.com/drive/folders/1tS1opPO1eGMnbg3JqmmTPu5iIHYn_s3p?usp=drive_link",
      "totalFrames": 174
      },
      {
      "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
      "options": [
          "Improper_Placement[310]",
          "Wrong_Component[304]",
          "FalseCall[003]",
          "Tombstoned_Component[307]",
          "Excess Solder[403]"
      ],
      "correctOption": 4,
      "framesFolder": "https://drive.google.com/drive/folders/1SZ2T9-P1fMVVQXvzEe1Agtt4d6rbudEJ?usp=drive_link",
      "totalFrames": 179
      },
      {
      "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
      "options": [
          "Missing_Component[306]",
          "Improper_Placement[310]",
          "Excess Solder[403]",
          "Extra_Component[305]",
          "FalseCall[003]"
      ],
      "correctOption": 2,
      "framesFolder": "https://drive.google.com/drive/folders/14qu6CkuPpQpaTIaJ-77TOIRrFPwW9w_r?usp=drive_link",
      "totalFrames": 176
      },
      {
      "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
      "options": [
          "Coplanarity_ Component_Lead[316]",
          "FalseCall[003]",
          "Solder_Bridge[409]",
          "Excess Solder[403]",
          "Tombstoned_Component[307]"
      ],
      "correctOption": 3,
      "framesFolder": "https://drive.google.com/drive/folders/1h7FuwziSkLv4dY58jUhExAnVbmcW7d7P?usp=drive_link",
      "totalFrames": 177
      },
      {
      "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
      "options": [
          "Wrong_Component[304]",
          "Excess Solder[403]",
          "Unsoldered_Connection[401]",
          "FalseCall[003]",
          "Coplanarity_ Component_Lead[316]"
      ],
      "correctOption": 1,
      "framesFolder": "https://drive.google.com/drive/folders/1I3hi24pU9HS1cKfQ38A4qwOCFclnX3px?usp=drive_link",
      "totalFrames": 173
      },
      {
      "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
      "options": [
          "Coplanarity_ Component_Lead[316]",
          "Improper_Placement[310]",
          "FalseCall[003]",
          "Excess Solder[403]",
          "Billboarded_Component[311]"
      ],
      "correctOption": 3,
      "framesFolder": "https://drive.google.com/drive/folders/1cQHll54tENAwKV3FQGKNKm-cEqQFNM1X?usp=drive_link",
      "totalFrames": 173
      },

  ]

  const questions = [
      {
          "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
          "options": [
              "FalseCall[003]",
              "Improper_Placement[310]",
              "Damaged _Lifted_pad[102]",
              "Insufficient_Solder[402]",
              "Excess Solder[403]"
          ],
          "correctOption": 2,
          "framesFolder": "https://drive.google.com/drive/folders/1cOZzy7krGvC_G2Ck_IjNxzI13SuJ4EE6?usp=drive_link",
          "totalFrames": 170
      },
      {
          "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
          "options": [
              "Coplanarity_ Component_Lead[316]",
              "Damaged _Lifted_pad[102]",
              "Solder_Balls_Splashes[408]",
              "Tombstoned_Component[307]",
              "FalseCall[003]"
          ],
          "correctOption": 1,
          "framesFolder": "https://drive.google.com/drive/folders/1PSLqD_ITCGqADbE_nk3MbDo33eGMFl1C?usp=drive_link",
          "totalFrames": 165
      },
      {
          "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
          "options": [
              "Missing_Component[306]",
              "FalseCall[003]",
              "Wrong_Orientation[309]",
              "Damaged _Lifted_pad[102]",
              "Damaged_Leads[303]"
          ],
          "correctOption": 3,
          "framesFolder": "https://drive.google.com/drive/folders/14fy6nEbx4H82SKoZA6zdIb_uqBtrM8C6?usp=drive_link",
          "totalFrames": 177
      },
      {
          "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
          "options": [
              "Missing_Component[306]",
              "FalseCall[003]",
              "Wrong_Component[304]",
              "Contamination[705]",
              "Solder_Bridge[409]"
          ],
          "correctOption": 3,
          "framesFolder": "https://drive.google.com/drive/folders/1sP5tvLqmkEZnZ0PHXul7MCGRo6RwCoYD?usp=drive_link",
          "totalFrames": 171
      },
      {
      "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
      "options": [
          "Coplanarity_ Component_Lead[316]",
          "Excess Solder[403]",
          "Solder_Bridge[409]",
          "Damaged_Leads[303]",
          "FalseCall[003]"
      ],
      "correctOption": 1,
      "framesFolder": "https://drive.google.com/drive/folders/1tS1opPO1eGMnbg3JqmmTPu5iIHYn_s3p?usp=drive_link",
      "totalFrames": 174
      },
      {
      "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
      "options": [
          "Improper_Placement[310]",
          "Wrong_Component[304]",
          "FalseCall[003]",
          "Tombstoned_Component[307]",
          "Excess Solder[403]"
      ],
      "correctOption": 4,
      "framesFolder": "https://drive.google.com/drive/folders/1SZ2T9-P1fMVVQXvzEe1Agtt4d6rbudEJ?usp=drive_link",
      "totalFrames": 179
      },
      {
      "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
      "options": [
          "Missing_Component[306]",
          "Improper_Placement[310]",
          "Excess Solder[403]",
          "Extra_Component[305]",
          "FalseCall[003]"
      ],
      "correctOption": 2,
      "framesFolder": "https://drive.google.com/drive/folders/14qu6CkuPpQpaTIaJ-77TOIRrFPwW9w_r?usp=drive_link",
      "totalFrames": 176
      },
      {
      "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
      "options": [
          "Coplanarity_ Component_Lead[316]",
          "FalseCall[003]",
          "Solder_Bridge[409]",
          "Excess Solder[403]",
          "Tombstoned_Component[307]"
      ],
      "correctOption": 3,
      "framesFolder": "https://drive.google.com/drive/folders/1h7FuwziSkLv4dY58jUhExAnVbmcW7d7P?usp=drive_link",
      "totalFrames": 177
      },
      {
      "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
      "options": [
          "Wrong_Component[304]",
          "Excess Solder[403]",
          "Unsoldered_Connection[401]",
          "FalseCall[003]",
          "Coplanarity_ Component_Lead[316]"
      ],
      "correctOption": 1,
      "framesFolder": "https://drive.google.com/drive/folders/1I3hi24pU9HS1cKfQ38A4qwOCFclnX3px?usp=drive_link",
      "totalFrames": 173
      },
      {
      "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
      "options": [
          "Coplanarity_ Component_Lead[316]",
          "Improper_Placement[310]",
          "FalseCall[003]",
          "Excess Solder[403]",
          "Billboarded_Component[311]"
      ],
      "correctOption": 3,
      "framesFolder": "https://drive.google.com/drive/folders/1cQHll54tENAwKV3FQGKNKm-cEqQFNM1X?usp=drive_link",
      "totalFrames": 173
      },
  ];

    // Inline JSON data for questions (already provided)
    let isReviewMode = false; // Default is false
    let currentQuestionIndex = 0;
    let zoomLevel = 1; // Initial zoom level
    let isDragging = false; // Dragging state
    let dragStartX = 0; // Initial mouse X position
    let dragStartY = 0; // Initial mouse Y position
    let imageTranslateX = 0; // Current image translation on X-axis
    let imageTranslateY = 0; // Current image translation on Y-axis;
    let timerInterval; // To store the interval
    let timeRemaining = 30 * 60; // 30 minutes in seconds
    let incorrectAnswers = 0; // Track incorrect answers
    const maxIncorrectAnswers = 2; // Allow up to 2 incorrect answers

    // Function to send results to Storyline
    function sendTestResultsToStoryline(status) {
        const message = {
            type: 'testResults',
            status: status, // 'passed' or 'not passed'
        };
        window.parent.postMessage(message, '*'); // Send message to parent frame (Storyline)
        console.log(status);
    }


    // Add this to your script.js in the web object
    window.addEventListener("message", function(event) {
        if (event.data.type === "userInfo") {
            const learnerName = event.data.learnerName;
            const learnerID = event.data.learnerID;

            // Use the received data
            console.log("User Name:", learnerName);
            console.log("User ID:", learnerID);

            // Optionally, store it in localStorage or use it directly
            localStorage.setItem("learnerName", learnerName);
            localStorage.setItem("learnerID", learnerID);
        }
    });


    document.addEventListener("DOMContentLoaded", () => {
        const loginForm = document.getElementById("loginForm");
        const loginError = document.getElementById("loginError");
        const startTestButton = document.getElementById("startTestButton");

        const validCredentials = {
            username: "testuser",
            password: "testpassword",
        };

        loginForm.addEventListener("submit", (e) => {
            e.preventDefault(); // Prevent form submission
            const username = document.getElementById("username").value;
            const password = document.getElementById("password").value;

            if (username === validCredentials.username && password === validCredentials.password) {
                loginError.classList.add("hidden");
                loginForm.classList.add("hidden");
                startTestButton.classList.remove("hidden");
            } else {
                loginError.classList.remove("hidden");
            }
        });
    });



    const draggableBox = document.getElementById('draggableBox');



    function startTimer() {
        const timerElement = document.getElementById('timer');

        timerInterval = setInterval(() => {
            // Calculate minutes and seconds
            const minutes = Math.floor(timeRemaining / 60);
            const seconds = timeRemaining % 60;

            // Update the timer display
            timerElement.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;

            // Check if time has run out
            if (timeRemaining <= 0) {
                clearInterval(timerInterval); // Stop the timer
                alert("Timpul a expirat! Testul s-a încheiat.");
                showResults(); // Show the results page
            }

            timeRemaining--; // Decrease time
        }, 1000);
    }






    // Utility function to shuffle an array
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    // Shuffle and select 4 questions
    function shuffleAndSelectQuestions() {
        const shuffled = questions.sort(() => Math.random() - 0.5);
        randomizedQuestions = shuffled.slice(0, 22); // Select 22 questions after shuffling

        // Start the timer when the test begins
        startTimer();
    }

    // Variables to store user answers
    const userAnswers = [];





    // Show results after the last question
    // Show results after the last question
    function showResults() {
        console.log("Executing showResults...");
        clearInterval(timerInterval);

        const resultsPage = document.getElementById('resultsPage');
        const questionsPage = document.querySelector('.container');
        const draggableBox = document.getElementById('draggableBox');

        // Hide the slider container when showing results
        draggableBox.classList.add('hidden');

        // Calculate score
        const correctAnswers = userAnswers.filter(answer => answer.selectedOption === answer.correctOption).length;
        const totalQuestions = randomizedQuestions.length;
        const score = Math.round((correctAnswers / totalQuestions) * 100);

        // Determine pass/fail status
        const passThreshold = 90; // Adjust threshold if needed
        const status = score >= passThreshold ? 'Passed' : 'Failed';

        // Save the result to the user's attempts
        const currentUser = JSON.parse(localStorage.getItem("currentUser"));
        const storedUsers = JSON.parse(localStorage.getItem("users"));

        // Add a new attempt to the current user's data
        const attempt = {
            id: `attempt${(currentUser.attempts?.length || 0) + 1}`,
            date: new Date().toLocaleString(),
            score: score,
            status: status,
            answers: userAnswers.map(answer => ({
                question: answer.question,
                selectedOption: answer.selectedOption,
                correctOption: answer.correctOption
            }))
        };

        if (!currentUser.attempts) {
            currentUser.attempts = [];
        }
        currentUser.attempts.push(attempt);

        // Update the global users list
        const userIndex = storedUsers.findIndex(u => u.id === currentUser.id);
        storedUsers[userIndex] = currentUser;
        localStorage.setItem("users", JSON.stringify(storedUsers));
        localStorage.setItem("currentUser", JSON.stringify(currentUser));

        // Update DOM elements for results
        const resultMessage = document.getElementById('resultMessage');
        const scoreMessage = document.getElementById('scoreMessage');
        const reviewList = document.getElementById('reviewList');

        resultMessage.innerText = status === 'Passed' ? 'Ai trecut testul! Felicitări!' : 'Nu ai trecut testul. Încearcă din nou!';
        scoreMessage.innerText = `Scorul tău: ${score}%`;

        reviewList.innerHTML = '';
        userAnswers.forEach((answer, index) => {
            const li = document.createElement('li');
            li.innerHTML = `<strong>Întrebarea ${index + 1}:</strong> ${answer.question}<br>
                            <span style="color: ${answer.selectedOption === answer.correctOption ? 'green' : 'red'};">
                            Răspuns ales: ${answer.selectedOption}</span><br>
                            Răspuns corect: ${answer.correctOption}`;
            reviewList.appendChild(li);
        });

        // Switch views
        questionsPage.classList.add('hidden');
        resultsPage.classList.remove('hidden');
        console.log("Results page should now be visible.");
    }



    // Restart the test
    function restartTest() {
        isReviewMode = false;
        currentQuestionIndex = 0;
        userAnswers.length = 0;
        shuffleAndSelectQuestions();
        displayQuestion(currentQuestionIndex);

        // Reset the timer
        clearInterval(timerInterval); // Clear the current timer interval
        timeRemaining = 30 * 60; // Reset the time to 30 minutes
        startTimer(); // Restart the timer

        // Ensure the slider is visible when restarting the test
        const draggableBox = document.getElementById('draggableBox');
        draggableBox.classList.remove('hidden');

        // Reset the results page and show the test page
        document.getElementById('resultsPage').classList.add('hidden');
        document.querySelector('.container').classList.remove('hidden');
    }





    // Add event listeners for results page buttons
    document.getElementById('reviewQuestionsButton').addEventListener('click', () => {
        isReviewMode = true; // Enable review mode
        currentQuestionIndex = 0;
        displayQuestion(currentQuestionIndex);

        document.getElementById('resultsPage').classList.add('hidden');
        document.querySelector('.container').classList.remove('hidden');
    });


    document.getElementById('restartButton').addEventListener('click', restartTest);



    // Navigate between questions
    // Navigate between questions
    function nextQuestion() {
        if (!isReviewMode) {
            // Validate the current answer
            const userAnswer = userAnswers[currentQuestionIndex];
            if (userAnswer && userAnswer.selectedOption !== userAnswer.correctOption) {
                incorrectAnswers++; // Increment incorrect answer count
            }
        }

        // Move to the next question only if within bounds
        if (currentQuestionIndex < randomizedQuestions.length - 1) {
            currentQuestionIndex++; // Increment only once
            displayQuestion(currentQuestionIndex); // Load the next question
        } else {
            showResults(); // Show results after all questions are answered
        }
    }




    function prevQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            displayQuestion(currentQuestionIndex);
        }
    }

    draggableBox.classList.remove('hidden');

    // Enable slider during review mode
    function displayQuestion(index) {
        const question = randomizedQuestions[index];
        const header = document.querySelector('.header');
        const draggableBox = document.getElementById('draggableBox');

        // Update the question counter
        const questionCounter = document.getElementById('questionCounter');
        questionCounter.textContent = `${index + 1}/${randomizedQuestions.length}`;

        // Update the header based on review mode
        if (isReviewMode) {
            const userAnswer = userAnswers[index];
            if (userAnswer && userAnswer.selectedOption === question.options[question.correctOption]) {
                header.style.backgroundColor = 'green'; // Correct answer
                header.firstChild.textContent = 'Corect'; // Update only the text part
            } else {
                header.style.backgroundColor = 'red'; // Incorrect answer
                header.firstChild.textContent = 'Incorect'; // Update only the text part
            }
        } else {
            header.style.backgroundColor = '#c62828'; // Default red header
            header.firstChild.textContent = 'Alege varianta corectă'; // Update only the text part
        }

        // Shuffle the options for the current question
        const shuffledOptions = isReviewMode ? question.options : shuffleArray([...question.options]);

        document.querySelector('.options-section h2').innerText = question.question;

        const optionsList = document.querySelector('.options-section ul');
        optionsList.innerHTML = ''; // Clear previous options

        shuffledOptions.forEach((option, i) => {
            const li = document.createElement('li');
            li.style.cursor = isReviewMode ? 'not-allowed' : 'pointer'; // Disable pointer cursor in review mode

            // Create the HTML for the option row
            li.innerHTML = `
                <div style="display: flex; align-items: center;">
                    <input type="radio" name="option" id="option${i}" value="${i}" style="margin-right: 10px;" ${isReviewMode ? 'disabled' : ''}>
                    <label for="option${i}" style="flex: 1;">${option}</label>
                </div>
            `;

            const radioInput = li.querySelector('input[type="radio"]');

            // Restore previously selected answer if it exists
            if (userAnswers[index]?.selectedOption === option) {
                radioInput.checked = true; // Mark as selected
            }

            if (!isReviewMode) {
                // Add click event listener to save the user's answer
                li.addEventListener('click', () => {
                    radioInput.checked = true; // Select the radio button programmatically

                    // Save the user's answer
                    userAnswers[index] = {
                        question: question.question,
                        selectedOption: option,
                        correctOption: question.options[question.correctOption],
                    };

                    // Highlight the selected option in red
                    const allOptions = optionsList.querySelectorAll('li label');
                    allOptions.forEach((label) => {
                        label.style.backgroundColor = 'transparent';
                        label.style.color = 'inherit';
                    });
                    li.querySelector('label').style.backgroundColor = '#C12033';
                    li.querySelector('label').style.color = 'white';

                    // Save the answer to local storage
                    const questionId = `q${index + 1}`;
                    const isCorrect = option === question.options[question.correctOption];
                    saveAnswer(questionId, isCorrect); // Save using the saveAnswer function
                });
            } else {
                // Highlight the user's selected answer and the correct answer
                const label = li.querySelector('label');
                if (option === question.options[question.correctOption]) {
                    label.style.border = '2px solid green'; // Highlight correct answer in green
                }
                if (userAnswers[index]?.selectedOption === option) {
                    label.style.backgroundColor = 'red'; // Highlight user's incorrect selection in red
                    label.style.color = 'white'; // Keep text color white
                }
            }

            optionsList.appendChild(li);
        });

        loadFrames(question.framesFolder, question.totalFrames);
    }






    function goToResults() {
        document.querySelector('.container').classList.add('hidden');
        document.getElementById('resultsPage').classList.remove('hidden');
    }



    // Restore zoom and drag functionality for the modal
    async function loadFrames(folderUrl, totalFrames) {
        const folderId = extractFolderId(folderUrl); // Extract the folder ID from the URL
        const frames = await fetchFrameUrls(folderId); // Fetch URLs from your backend
    
        const gifFrame = document.getElementById('gifFrame');
        const frameSlider = document.getElementById('frameSlider');
    
        // Set slider max dynamically
        frameSlider.max = totalFrames;
        frameSlider.value = 1;
        gifFrame.src = frames[0]; // Load the first frame
    
        // Ensure the slider changes frames dynamically
        frameSlider.oninput = () => {
            const frameIndex = Math.min(frameSlider.value - 1, frames.length - 1); // Prevent exceeding range
            gifFrame.src = frames[frameIndex]; // Update the image source
        };
    
        // Add click event for fullscreen modal
        gifFrame.onclick = () => openModal(gifFrame.src);
    
        // Add scroll event for zooming
        gifFrame.addEventListener('wheel', handleScrollZoom);
    }
    
    // Helper function to extract folder ID from Google Drive folder URL
    function extractFolderId(folderUrl) {
        const match = folderUrl.match(/[-\w]{25,}/); // Matches the Google Drive ID format
        return match ? match[0] : null;
    }
    
    // Helper function to fetch frame URLs from the backend
    async function fetchFrameUrls(folderId) {
        const response = await fetch(`YOUR_APPS_SCRIPT_URL?folderId=${folderId}`);
        const data = await response.json();
        return data.frames; // Assuming your Apps Script returns an array of URLs
    }
    


    // Modal functionality
    // Restore modal functionality
    function openModal(imageSrc) {
        const modal = document.getElementById('imageModal');
        const modalImage = document.getElementById('modalImage');
        const closeModal = document.querySelector('.modal .close');

        zoomLevel = 1; // Reset zoom level when opening modal
        imageTranslateX = 0;
        imageTranslateY = 0;
        modalImage.style.transform = `scale(${zoomLevel}) translate(0, 0)`; // Reset zoom and translation
        modalImage.src = imageSrc; // Set the modal image source
        modal.style.display = 'block'; // Show the modal

        // Close the modal when the close button is clicked
        closeModal.onclick = () => {
            modal.style.display = 'none';
        };

        // Close the modal when clicking outside the image
        modal.onclick = (event) => {
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        };

        // Add drag functionality to the modal image
        modalImage.onmousedown = startDragging;
        document.onmouseup = stopDragging;
        document.onmousemove = dragImage;

        // Zoom in and out
        const zoomInButton = document.getElementById('zoomIn');
        const zoomOutButton = document.getElementById('zoomOut');

        zoomInButton.onclick = () => zoomModalImage(0.3); // Zoom in
        zoomOutButton.onclick = () => zoomModalImage(-0.5); // Zoom out
    }

    // Start dragging the image
    function startDragging(event) {
        isDragging = true;
        dragStartX = event.clientX;
        dragStartY = event.clientY;
        event.preventDefault(); // Prevent selection while dragging
    }

    // Stop dragging the image
    function stopDragging() {
        isDragging = false;
    }

    // Drag the image
    function dragImage(event) {
        if (!isDragging) return;

        const deltaX = event.clientX - dragStartX;
        const deltaY = event.clientY - dragStartY;

        imageTranslateX += deltaX / zoomLevel; // Adjust for zoom level
        imageTranslateY += deltaY / zoomLevel;

        const modalImage = document.getElementById('modalImage');
        modalImage.style.transform = `scale(${zoomLevel}) translate(${imageTranslateX}px, ${imageTranslateY}px)`;

        dragStartX = event.clientX;
        dragStartY = event.clientY;
    }

    // Zoom the modal image
    function zoomModalImage(step) {
        zoomLevel += step;
        zoomLevel = Math.max(1, zoomLevel); // Prevent zooming out below 1x
        const modalImage = document.getElementById('modalImage');
        modalImage.style.transform = `scale(${zoomLevel}) translate(${imageTranslateX}px, ${imageTranslateY}px)`; // Apply zoom and translation
    }

    // Function to handle zoom using the scroll wheel
    function handleScrollZoom(event) {
        event.preventDefault(); // Prevent the default scrolling behavior
        const zoomStep = event.deltaY < 0 ? 0.1 : -0.1; // Scroll up to zoom in, down to zoom out
        zoomLevel += zoomStep;
        zoomLevel = Math.max(1, Math.min(zoomLevel, 5)); // Clamp zoom level between 1x and 5x

        const modalImage = document.getElementById('modalImage');
        modalImage.style.transform = `scale(${zoomLevel}) translate(${imageTranslateX}px, ${imageTranslateY}px)`;
    }

    // Add the event listener to the image for scroll wheel zoom
    const gifFrame = document.getElementById('gifFrame');
    gifFrame.addEventListener('wheel', handleScrollZoom);

    // Also add the listener for modal zoom if needed
    const modalImage = document.getElementById('modalImage');
    modalImage.addEventListener('wheel', handleScrollZoom);


    const slider = document.getElementById('frameSlider');
    const tooltip = document.getElementById('sliderTooltip');


    // Local AOI Test System with User Tracking and Admin Dashboard

    // Dummy user database
    const users = [
        { id: "user1", name: "User 1", role: "user", answers: {} },
        { id: "user2", name: "User 2", role: "user", answers: {} },
        { id: "user3", name: "User 3", role: "user", answers: {} },
        { id: "admin", name: "Admin", role: "admin", answers: {} }
    ];

    // Save users to localStorage
    if (!localStorage.getItem("users")) {
        localStorage.setItem("users", JSON.stringify(users));
    }

    // Login function
    function login(username) {
        const storedUsers = JSON.parse(localStorage.getItem("users"));
        const user = storedUsers.find(u => u.id === username);

        if (user) {
            localStorage.setItem("currentUser", JSON.stringify(user));
            if (user.role === "admin") {
                window.location.href = "admin.html";
            } else {
                window.location.href = "Test_AOI.html";
            }
        } else {
            alert("Invalid user!");
        }
    }

    // Save answer function
    function saveAnswer(questionId, isCorrect) {
        const currentUser = JSON.parse(localStorage.getItem("currentUser"));
        const storedUsers = JSON.parse(localStorage.getItem("users"));

        // Update user answers
        currentUser.answers[questionId] = isCorrect ? "correct" : "wrong";

        // Update global user database
        const userIndex = storedUsers.findIndex(u => u.id === currentUser.id);
        storedUsers[userIndex] = currentUser;
        localStorage.setItem("users", JSON.stringify(storedUsers));
        localStorage.setItem("currentUser", JSON.stringify(currentUser));
    }


    // Admin view function
    function loadAdminDashboard() {
        const storedUsers = JSON.parse(localStorage.getItem("users"));
        const resultsContainer = document.getElementById("resultsContainer");
        resultsContainer.innerHTML = ""; // Clear previous content

        if (!storedUsers || storedUsers.length === 0) {
            resultsContainer.innerHTML = "<p>No user data found</p>";
            return;
        }

        storedUsers.forEach(user => {
            if (user.role === "user") {
                // Create user section
                const userSection = document.createElement("div");
                userSection.classList.add("user-section");

                // User header
                const userHeader = document.createElement("div");
                userHeader.classList.add("user-header");
                userHeader.innerHTML = `
                    <h3>${user.name}</h3>
                    <span class="toggle-icon">+</span>
                `;
                userHeader.onclick = () => toggleCollapse(userHeader);

                // User content
                const userContent = document.createElement("div");
                userContent.classList.add("user-content");
                userContent.style.display = "none";

                // List attempts
                if (user.attempts && user.attempts.length > 0) {
                    const attemptsList = document.createElement("ul");
                    attemptsList.style.listStyleType = "none";
                    attemptsList.style.padding = "0";

                    user.attempts.forEach(attempt => {
                        const attemptItem = document.createElement("li");
                        attemptItem.style.marginBottom = "10px";
                        attemptItem.classList.add("attempt-section");

                        // Attempt Header
                        const attemptHeader = document.createElement("div");
                        attemptHeader.classList.add("attempt-header");
                        attemptHeader.innerHTML = `
                            <p><strong>Attempt ID:</strong> ${attempt.id}</p>
                            <p><strong>Date:</strong> ${attempt.date}</p>
                            <p><strong>Score:</strong> ${attempt.score}%</p>
                            <p><strong>Status:</strong> ${attempt.status}</p>
                            <span class="toggle-icon">+</span>
                        `;
                        attemptHeader.onclick = () => toggleCollapse(attemptHeader);

                        // Attempt Content
                        const attemptContent = document.createElement("div");
                        attemptContent.classList.add("attempt-content");
                        attemptContent.style.display = "none";

                        // Populate answers for this attempt
                        if (attempt.answers && Object.keys(attempt.answers).length > 0) {
                            Object.entries(attempt.answers).forEach(([questionId, answer]) => {
                                const questionDetail = document.createElement("p");
                                questionDetail.innerHTML = `
                                    <strong>Question:</strong> ${answer.question}<br>
                                    <strong>Your Answer:</strong> ${answer.selectedOption}<br>
                                    <strong>Correct Answer:</strong> ${answer.correctOption}
                                `;
                                attemptContent.appendChild(questionDetail);
                            });
                        } else {
                            attemptContent.innerHTML = "<p>No answers recorded for this attempt.</p>";
                        }

                        // Append header and content to the attempt section
                        attemptItem.appendChild(attemptHeader);
                        attemptItem.appendChild(attemptContent);
                        attemptsList.appendChild(attemptItem);
                    });

                    userContent.appendChild(attemptsList);
                } else {
                    userContent.innerHTML = "<p>No attempts yet</p>";
                }

                // Append header and content to user section
                userSection.appendChild(userHeader);
                userSection.appendChild(userContent);
                resultsContainer.appendChild(userSection);
            }
        });
    }



    function setupSearchFunctionality() {
        const searchBar = document.getElementById("searchBar");
        const resultsContainer = document.getElementById("resultsContainer");

        searchBar.addEventListener("input", () => {
            const query = searchBar.value.toLowerCase(); // Get search query
            const userSections = resultsContainer.getElementsByClassName("user-section");

            Array.from(userSections).forEach(section => {
                const userName = section.querySelector(".user-header h3").textContent.toLowerCase();

                // Show or hide the section based on the query match
                if (userName.includes(query)) {
                    section.style.display = "block";
                } else {
                    section.style.display = "none";
                }
            });
        });
    }


    function toggleCollapse(header) {
        const section = header.parentElement;
        const content = section.querySelector('.user-content, .attempt-content');
        const toggleIcon = header.querySelector('.toggle-icon');

        if (content.style.display === 'block') {
            content.style.display = 'none';
            toggleIcon.textContent = '+';
        } else {
            content.style.display = 'block';
            toggleIcon.textContent = '−';
        }
    }




    // Logout function
    function logout() {
        localStorage.removeItem("currentUser");
        window.location.href = "index.html";
    }




    // Example usage
    // Call `saveAnswer('q1', true)` when a user answers a question.
    // Call `loadAdminDashboard()` on the admin page to display all results.


    // Initialize
    shuffleAndSelectQuestions();
    displayQuestion(currentQuestionIndex);

</script>